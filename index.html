<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=()">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://unpkg.com 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' https://unpkg.com wss://relay.damus.io wss://nos.lol wss://relay.snort.social wss://relay.primal.net wss://relay.nostr.band; img-src 'self' data:; base-uri 'none'; frame-ancestors 'none';">
    <title>pingproof.life</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- Setup Screen -->
        <div id="setupScreen">
            <h1>pingproof.life</h1>
                <div class="tagline">simple check-in timer that posts to nostr and tags your contact</div>

        <div id="generateSection" class="section">
            <div class="security-context">100% frontend app - keys stored locally</div>
            <button onclick="generateKeys()">generate check-in identity</button>
            <div style="margin: 16px 0; color: var(--text-secondary); font-size: 14px;">or</div>
            <button onclick="showImportForm()" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary);">import check-in keys only</button>
        </div>

        <div id="importSection" class="section hidden">
            <div class="import-warning">never import your main nostr identity - check-in temporary keys only</div>
            <input type="text" id="importNsec" placeholder="paste temporary check-in nsec here">
            <div style="margin: 8px 0;">
                <button onclick="importKeys()">import</button>
                <button onclick="cancelImport()" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary); margin-left: 8px;">cancel</button>
            </div>
        </div>

            <div id="keySection" class="key-section hidden">
                <h3>your check-in identity</h3>
            <div class="key-display">
                <label>private key (NEVER SHARE):</label>
                <div class="key-value" id="nsecDisplay" data-hidden="true">•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••</div>
                <button class="key-toggle-btn" onclick="toggleNsecVisibility()">show</button>
                <button onclick="copyNsec()">copy</button>
            </div>
                <div class="key-display">
                    <label>public key (share with check-in contact):</label>
                    <div class="key-value" id="npubDisplay"></div>
                    <button onclick="copyNpub()">copy</button>
                </div>
            </div>

            <div id="configSection" class="section hidden">
            <label style="display: block; margin-bottom: 8px; font-size: 14px; color: var(--text-secondary); font-weight: 500;">display name (optional)</label>
            <input type="text" id="displayName" placeholder="display name" maxlength="50">

            <label style="display: block; margin-top: 16px; margin-bottom: 8px; font-size: 14px; color: var(--text-secondary); font-weight: 500;">enter your contact's public key (npub) - they'll be tagged when posted</label>
            <input type="text" id="contactNpub" placeholder="contact npub">

            <label style="display: block; margin-top: 16px; margin-bottom: 8px; font-size: 14px; color: var(--text-secondary); font-weight: 500;">this will be publicly visible on nostr</label>
            <textarea id="checkinMessage" rows="3" placeholder="check-in post"></textarea>
                <div class="timer-selection">
                    <span style="font-size: 14px; color: var(--text-secondary);">check in every:</span>
                    <div style="margin-top: 8px;">
                        <button class="timer-btn" onclick="selectTimer(0.0167, this)">1m (test)</button>
                        <button class="timer-btn" onclick="selectTimer(1, this)">1h</button>
                        <button class="timer-btn" onclick="selectTimer(6, this)">6h</button>
                        <button class="timer-btn" onclick="selectTimer(12, this)">12h</button>
                        <button class="timer-btn selected" onclick="selectTimer(24, this)">24h</button>
                        <button class="timer-btn" onclick="selectTimer(48, this)">48h</button>
                        <button class="timer-btn" onclick="selectTimer(72, this)">72h</button>


                    </div>
                </div>
                <button onclick="startTimer()">start countdown</button>
                <div id="validationMessage" class="validation-message hidden"></div>
            </div>
            <div id="backupSection" class="section hidden">
                <h3>backup your check-in setup</h3>
                <div style="margin-bottom: 16px; font-size: 14px; color: var(--text-secondary);">
                    save this information in a secure location before starting the timer
                </div>
                <button onclick="showBackupData()" style="margin-right: 8px;">view backup data</button>
                <button onclick="downloadBackup()" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary);">download as file</button>
                
                <div id="backupDisplay" class="key-section hidden" style="margin-top: 16px;">
                    <pre id="backupContent" style="text-align: left; font-size: 12px; line-height: 1.4; white-space: pre-wrap;"></pre>
                    <button onclick="copyBackupData()" style="margin-top: 12px; background: transparent; border: 1px solid var(--border); color: var(--text-secondary);">copy all</button>
                    <button onclick="actuallyStartTimer()" style="margin-top: 12px; margin-left: 8px;">start timer now</button>
                </div>
            </div>
            <div class="browser-warning">important: only works while this browser tab stays open and awake</div>
            <div class="nostr-attribution">
                <span class="attribution-text">powered by <span class="nostr-purple">nostr</span></span>
            </div>
        </div>

        <!-- Timer Screen -->
        <div id="timerScreen" class="hidden">
            <h1>pingproof.life</h1>
            
            <button onclick="backToSetup()" class="back-button">← back to setup</button>
            
            <div class="status" id="connectionStatus"></div>
            
            <div class="timer" id="timerDisplay">00:00:00</div>

            <div class="connection-info-link" onclick="toggleConnectionInfo()">
                <span class="info-text">relay info</span>
            </div>

            <div id="connectionInfo" class="connection-details hidden">
            <div class="detail-header">Check-in Relay System</div>
            <div class="detail-text">
                When timer expires, connects simultaneously to:<br>
                relay.damus.io • nos.lol • relay.snort.social<br>
                relay.primal.net • relay.nostr.band
            </div>
        </div>

        <div class="deadline" id="deadlineDisplay">next deadline: --</div>
        <div class="status" style="font-size: 12px; margin-bottom: 8px;">[timer runs only while tab is open; phone background unreliable]</div>
        <div class="status" id="publicPostReminder">[check-in post will be public]</div>

            <button onclick="checkIn(this)">i'm here</button>

            <div style="margin-top: 40px;">
            <button onclick="stopTimer()" style="font-size: 14px;">stop timer</button>
            <div id="stopConfirmation" class="hidden" style="margin-top: 24px; text-align: center;">
                <div style="margin-bottom: 16px; font-size: 14px; color: var(--text-secondary);">stop check-in timer?</div>
                <button onclick="confirmStop()" style="font-size: 14px; margin-right: 8px;">yes, stop timer</button>
                <button onclick="cancelStop()" style="font-size: 14px; background: transparent; border: 1px solid var(--border); color: var(--text-secondary);">cancel</button>
            </div>
            </div>

        </div>
    </div>
        <footer class="app-footer">
            pingproof.life is a frontend-only hobby project. messages are posted publicly on nostr and may be visible across apps. not for emergencies. hosted on <a href="https://github.com/tcraid0/Pingproof_life" target="_blank" rel="noopener">github pages</a>. use responsibly.
        </footer>
    <script src="https://unpkg.com/nostr-tools@1.17.0/lib/nostr.bundle.js"></script>
    <script>
        // State management
        let state = {
            nsec: null,
            npub: null,
            contactNpub: null,
            checkInMessage: null,
            timerInterval: null,
            checkInInterval: null,
            deadline: null,
            countdownInterval: null
            };

          // Timer selection state
        let selectedTimerHours = 24; // Default to 24 hours

        function selectTimer(hours, el) {
        selectedTimerHours = hours;
        document.querySelectorAll('.timer-btn').forEach(btn => btn.classList.remove('selected'));
        if (el) el.classList.add('selected');
        }


        // Key Manager Module
        const KeyManager = {
            generate: () => {
                try {
                    const privateKey = window.NostrTools.generatePrivateKey();
                    const publicKey = window.NostrTools.getPublicKey(privateKey);
                    const nsec = window.NostrTools.nip19.nsecEncode(privateKey);
                    const npub = window.NostrTools.nip19.npubEncode(publicKey);
                    
                    // Clear sensitive data
                    // Note: Cannot clear string from memory in JavaScript
                    
                    return { nsec, npub };
                } catch (error) {
                    console.error('Key generation failed:', error.message);
                    throw error;
                }
            },
            
            store: (nsec, npub) => {
                localStorage.setItem('proof_nsec', nsec);
                localStorage.setItem('proof_npub', npub);
            },
            
            retrieve: () => {
                return {
                    nsec: localStorage.getItem('proof_nsec'),
                    npub: localStorage.getItem('proof_npub')
                };
            },
            
            clear: () => {
                localStorage.removeItem('proof_nsec');
                localStorage.removeItem('proof_npub');
                localStorage.removeItem('proof_config');
            }
        };

        // Nostr Client Module
        const NostrClient = {
            sendMessage: async (message, contactNpub, userNsec) => {
                try {
                    // Decode keys
                    const decSk = window.NostrTools.nip19.decode(userNsec);
                    if (decSk.type !== 'nsec') throw new Error('expected nsec');
                    const privateKey = decSk.data; // hex

                    const decContact = window.NostrTools.nip19.decode(contactNpub);
                    if (decContact.type !== 'npub') throw new Error('invalid contact npub');
                    const contactPubkey = String(decContact.data); // full hex pubkey

                    
                    // Create event
                    const event = {
                        kind: 1,
                        pubkey: window.NostrTools.getPublicKey(privateKey),
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [['p', contactPubkey]],
                        content: message
                    };
                    
                    // Defensive: ensure we’re not re-signing a prior event
                    delete event.id;
                    delete event.sig;

                    // Sign with current API (signEvent is deprecated)
                    const eventId = window.NostrTools.getEventHash(event);
                    const signature = window.NostrTools.getSignature(event, privateKey);
                    const signedEvent = {
                        ...event,
                        id: eventId,
                        sig: signature
                    };

                    // Optional sanity checks (keep these!)
                    const valid = window.NostrTools.validateEvent(signedEvent);
                    if (!valid) {
                        console.error('Invalid event structure', {
                            kind: signedEvent.kind,
                            pubkeyLen: signedEvent.pubkey?.length,
                            created_at: signedEvent.created_at,
                            tags: signedEvent.tags,
                            isTagsArray: Array.isArray(signedEvent.tags),
                            tag0: signedEvent.tags?.[0],
                            tag0Types: signedEvent.tags?.[0]?.map(v => typeof v),
                            contentType: typeof signedEvent.content,
                            hasId: !!signedEvent.id,
                            hasSig: !!signedEvent.sig
                        });
                        throw new Error('invalid event');
                    }
                    if (!window.NostrTools.verifySignature(signedEvent)) {
                    console.error('Signature verification failed — pubkey/secret mismatch');
                    }

                    // Send to relays
                    await sendToNostr(signedEvent);

                    
                } catch (error) {
                    console.error('Failed to send message:', error.message);
                    throw error;
                }
            }
        };

        // Profile Publisher Module  
        const ProfilePublisher = {
            publish: async (displayName, userNsec) => {
                if (!displayName) return;
                
                try {
                    const { data: privateKey } = window.NostrTools.nip19.decode(userNsec);
                    const profileEvent = {
                        kind: 0,
                        pubkey: window.NostrTools.getPublicKey(privateKey),
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [],
                        content: JSON.stringify({ name: displayName })
                    };
                    
                    const eventId = window.NostrTools.getEventHash(profileEvent);
                    const signature = window.NostrTools.getSignature(profileEvent, privateKey);
                    await sendToNostr({ ...profileEvent, id: eventId, sig: signature });
                } catch (error) {
                    console.warn('Failed to publish profile:', error.message);
                }
            }
        };

        // Timer Module
        const Timer = {
            start: () => {
                const config = JSON.parse(localStorage.getItem('proof_config'));
                if (!config) return;
                
                // Clear any previous status messages
                document.getElementById('connectionStatus').textContent = '';
                
                // Set initial deadline
                state.deadline = new Date(Date.now() + config.timerInterval);
                localStorage.setItem('proof_deadline', state.deadline.toISOString());
                
                // Start countdown
                Timer.updateCountdown();
                state.countdownInterval = setInterval(Timer.updateCountdown, 1000);
            },
            
            reset: () => {
                const config = JSON.parse(localStorage.getItem('proof_config'));
                if (!config) return;
                
                // Reset deadline
                state.deadline = new Date(Date.now() + config.timerInterval);
                localStorage.setItem('proof_deadline', state.deadline.toISOString());
                
                // Update display
                updateDeadlineDisplay();
            },
            
            updateCountdown: () => {
    if (!state.deadline) return;
    
    const now = Date.now();
    const remaining = state.deadline - now;
    
    if (remaining <= 0) {
        Timer.onExpire();
        return;
    }
    
    // Calculate hours, minutes, seconds
    const hours = Math.floor(remaining / (1000 * 60 * 60));
    const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
    
    // Update display
    document.getElementById('timerDisplay').textContent = 
        `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
},

    onExpire: async () => {
        clearInterval(state.countdownInterval);
        document.getElementById('timerDisplay').textContent = '00:00:00';
        const statusEl = document.getElementById('connectionStatus');
        statusEl.textContent = '[sending check-in message]';
        statusEl.setAttribute('data-state', 'sending');
        
        try {
            const config = JSON.parse(localStorage.getItem('proof_config'));
            const keys = KeyManager.retrieve();
            
            // Send check-in message first (priority)
            await NostrClient.sendMessage(
                config.checkInMessage,     // message
                config.contactNpub,        // contact npub
                keys.nsec                  // signer nsec
            );

            // Send profile after (non-blocking)
            if (config.displayName) {
                ProfilePublisher.publish(config.displayName, keys.nsec);
            }

            Timer.showMessageSentScreen();

        } catch (error) {
            Timer.showMessageFailedScreen();
        }
    }

    }; // Timer module ends here

        // Handle page visibility changes to maintain timer accuracy
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && state.deadline) {
                const now = new Date();
                if (state.deadline < now) {
                    // Deadline passed while page was hidden (sleep/minimize/tab switch)
                    clearInterval(state.countdownInterval);
                    Timer.showDeadlinePassedScreen();
                } else {
                    // Resume normal countdown
                    Timer.updateCountdown();
                    if (!state.countdownInterval) {
                        state.countdownInterval = setInterval(Timer.updateCountdown, 1000);
                    }
                }
            }
        });

        // Helper function to send to Nostr relays
            async function sendToNostr(signedEvent) {
                const relays = [
                    'wss://relay.damus.io',
                    'wss://nos.lol', 
                    'wss://relay.snort.social',
                    'wss://relay.primal.net',
                    'wss://relay.nostr.band'
                ];
        
        // Connect to all relays simultaneously
        const relayPromises = relays.map(async (relayUrl) => {
            try {
                const relay = window.NostrTools.relayInit(relayUrl);
                
                // Wait for connection with timeout
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Connection timeout')), 5000);
                    relay.on('connect', () => {
                        clearTimeout(timeout);
                        resolve();
                    });
                    relay.on('error', (err) => {
                        clearTimeout(timeout);
                        reject(err);
                    });
                    relay.connect();
                });
                
                // Publish and return success (simplified for compatibility)
                relay.publish(signedEvent);
                await new Promise((resolve) => {
                    // Give relay time to process, then resolve
                    setTimeout(() => resolve(), 2000);
                });
                relay.close();
                return { success: true, relay: relayUrl };

            } catch (error) {
                console.warn(`Relay ${relayUrl} failed:`, error.message);
                return { success: false, relay: relayUrl, error: error.message };
            }
        });
        
        // Wait for all attempts to complete
        const results = await Promise.all(relayPromises);
        const successful = results.filter(r => r.success);

        if (successful.length > 0) {
            const relayNames = successful.map(r => r.relay.split('.')[1] || r.relay.split('/')[2].split('.')[0]).join(', ');
            document.getElementById('connectionStatus').textContent = `[sent to ${successful.length}/5 relays: ${relayNames}]`;
        } else {
            // Retry once more with increased timeout
            console.warn('First attempt failed, retrying...');
            document.getElementById('connectionStatus').textContent = '[retrying relay connections...]';
            
            const retryPromises = relays.map(async (relayUrl) => {
            try {
                const relay = window.NostrTools.relayInit(relayUrl);
                await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => reject(new Error('Retry timeout')), 10000);
                        relay.on('connect', () => {
                            clearTimeout(timeout);
                            resolve();
                        });
                        relay.connect();
                    });
                    relay.publish(signedEvent);
                    await new Promise((resolve) => {
                        setTimeout(() => resolve(), 2000);
                    });
                    relay.close();
                    return { success: true, relay: relayUrl };

                } catch (error) {
                    return { success: false, relay: relayUrl };
                }
            });
    
    const retryResults = await Promise.all(retryPromises);
    const retrySuccessful = retryResults.filter(r => r.success);
    
    if (retrySuccessful.length > 0) {
        const retryRelayNames = retrySuccessful.map(r => r.relay.split('.')[1] || r.relay.split('/')[2].split('.')[0]).join(', ');
        document.getElementById('connectionStatus').textContent = `[sent to ${retrySuccessful.length}/5 relays after retry: ${retryRelayNames}]`;
    } else {
        throw new Error('Failed to publish to any relay after retry');
    }
}
    }

        // UI Functions
        function generateKeys() {
            try {
                const keys = KeyManager.generate();
                state.nsec = keys.nsec;
                state.npub = keys.npub;
                
                // Display keys (nsec starts hidden)
                document.getElementById('nsecDisplay').textContent = '••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••';
                document.getElementById('nsecDisplay').setAttribute('data-hidden', 'true');
                document.getElementById('npubDisplay').textContent = keys.npub;
                
                // Show sections
                document.getElementById('generateSection').classList.add('hidden');
                document.getElementById('keySection').classList.remove('hidden');
                document.getElementById('configSection').classList.remove('hidden');

                // Hide tagline
                document.querySelector('.tagline').classList.add('hidden');
                
                // Store keys
                KeyManager.store(keys.nsec, keys.npub);
            } catch (error) {
                showValidationMessage('failed to generate keys. please refresh and try again.');
            }
        }

        function backToStart() {
            // Hide current sections
            document.getElementById('keySection').classList.add('hidden');
            document.getElementById('configSection').classList.add('hidden');
            
            // Show initial section
            document.getElementById('generateSection').classList.remove('hidden');
            
            // Show tagline
            document.querySelector('.tagline').classList.remove('hidden');
                        
            // Clear any generated keys from display (but keep in localStorage)
            document.getElementById('nsecDisplay').textContent = '••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••';
            document.getElementById('npubDisplay').textContent = '';
        }

        function copyNsec() {
            try {
                navigator.clipboard.writeText(state.nsec);
                showCopyFeedback('nsec');
            } catch (error) {
                console.warn('Failed to copy nsec:', error);
            }
        }

        function copyNpub() {
            try {
                navigator.clipboard.writeText(state.npub);
                showCopyFeedback('npub');
            } catch (error) {
                console.warn('Failed to copy npub:', error);
            }
        }

        function startTimer() {
            const contactInput = document.getElementById('contactNpub');
            const contactNpub = contactInput.value.trim();
            const checkInMessage = document.getElementById('checkinMessage').value.trim();
            const displayName = document.getElementById('displayName').value.trim();
            const timerHours = selectedTimerHours;
            
            if (!contactNpub || !checkInMessage || !timerHours) {
                showValidationMessage('please fill in all fields');
                return;
            }
            
            // Validate npub (must decode and be type 'npub')
                try {
                    const dec = window.NostrTools.nip19.decode(contactNpub);
                    if (dec.type !== 'npub') throw new Error('not npub');
                } catch {
                    showValidationMessage('invalid check-in contact npub');
                    return;
                }
            
            // Save config
            const config = {
                contactNpub,
                checkInMessage,
                timerInterval: timerHours * 60 * 60 * 1000,
                displayName: displayName || null
            };
            try {
                localStorage.setItem('proof_config', JSON.stringify(config));
            } catch (e) {
                showValidationMessage('could not save configuration to this browser');
                return;
            }
            // Show backup section first
                document.getElementById('configSection').classList.add('hidden');
                document.getElementById('backupSection').classList.remove('hidden');
            }

        function checkIn(btn) {
        // Prevent double-clicks
        if (!btn || btn.disabled) return;

        btn.disabled = true;
        btn.textContent = 'resetting...';

        Timer.reset();

        setTimeout(() => {
            btn.disabled = false;
            btn.textContent = "i'm here";
        }, 1000);
        }


        function stopTimer() {
            showStopConfirmation();
        }

        function showStopConfirmation() {
            document.getElementById('stopConfirmation').classList.remove('hidden');
        }

        function confirmStop() {
            clearInterval(state.countdownInterval);
            KeyManager.clear();
            location.reload();
        }


        function cancelStop() {
            document.getElementById('stopConfirmation').classList.add('hidden');
        }

        function updateDeadlineDisplay() {
            if (!state.deadline || !(state.deadline instanceof Date)) return;
            
            const options = { 
                month: 'short', 
                day: 'numeric', 
                hour: 'numeric', 
                minute: '2-digit',
                hour12: true 
            };
            
            document.getElementById('deadlineDisplay').textContent = 
                `next deadline: ${state.deadline.toLocaleDateString('en-US', options).toLowerCase()}`;
        }

        // Check for existing session on load
        window.addEventListener('load', () => {
            const keys = KeyManager.retrieve();
            const config = localStorage.getItem('proof_config');
            const deadline = localStorage.getItem('proof_deadline');
            
        // Restore formatted display in contact field if config exists
        if (config) {
            try {
                const configData = JSON.parse(config);
        // Validate required fields exist
        if (!configData.contactNpub || !configData.checkInMessage || !configData.timerInterval) {
            throw new Error('Invalid config');
        }
        const contactInput = document.getElementById('contactNpub');
        if (configData.contactNpub && contactInput) {
            contactInput.value = configData.contactNpub; // full string, no shortening
        }

    } catch (error) {
        console.error('Corrupted config detected, clearing...');
        KeyManager.clear();
        location.reload();
    }
}
            
            if (keys.nsec && config && deadline) {
                // Validate deadline is a real date
                const deadlineDate = new Date(deadline);
                if (isNaN(deadlineDate.getTime())) {
                    // Date is corrupted, clear everything and start fresh
                    KeyManager.clear();
                    location.reload();
                    return;
                }
                
                // Restore state
                state.nsec = keys.nsec;
                state.npub = keys.npub;
                state.deadline = deadlineDate;
                
                // Check if deadline has passed
                const now = new Date();
                const timeSinceDeadline = now - state.deadline;
                
                // Auto-expire timers older than 7 days
                if (timeSinceDeadline > 7 * 24 * 60 * 60 * 1000) {
                    KeyManager.clear();
                    location.reload();
                    return;
                }
                
                // Only trigger if deadline passed within last 5 minutes (avoid false triggers from old sessions)
                if (state.deadline < now && timeSinceDeadline < 5 * 60 * 1000) {
                Timer.showDeadlinePassedScreen();
                } else if (state.deadline < now) {
                    // Deadline too old, clear and restart
                    KeyManager.clear();
                    location.reload();
                } else {
                    Timer.showProtectionPausedScreen();
                }
            }
        });

        function showCopyFeedback(keyType) {
            const button = keyType === 'nsec' ? 
                document.querySelector('.key-display button[onclick="copyNsec()"]') :
                document.querySelector('.key-display button[onclick="copyNpub()"]');
            
            const originalText = button.textContent;
            button.textContent = '✓';
            button.style.background = 'var(--accent)';
            button.style.color = '#ffffff';
            
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '';
                button.style.color = '';
            }, 325);
        }

        // NEW: copy last event id helper
        function copyEventId() {
        const el = document.getElementById('eventIdValue');
        if (!el || !el.textContent || el.textContent === '--') return;

        navigator.clipboard.writeText(el.textContent).then(() => {
            const btn = document.getElementById('copyEventIdBtn');
            if (!btn) return;
            const original = btn.textContent;
            btn.textContent = '✓ copied';
            btn.style.background = 'var(--accent)';
            btn.style.color = '#fff';
            setTimeout(() => {
                btn.textContent = original;
                btn.style.background = '';
                btn.style.color = '';
            }, 700);
        }).catch((e) => {
            console.warn('clipboard write failed (event id):', e);
            showValidationMessage('could not copy to clipboard');
            return;
        });
        }

       function toggleNsecVisibility() {
            const nsecDisplay = document.getElementById('nsecDisplay');
            const toggleButton = document.querySelector('.key-toggle-btn');
            const isHidden = nsecDisplay.getAttribute('data-hidden') === 'true';
            
            if (isHidden) {
                // Show the actual nsec
                nsecDisplay.textContent = state.nsec;
                nsecDisplay.setAttribute('data-hidden', 'false');
                toggleButton.textContent = 'hide';
            } else {
                // Hide with dots
                nsecDisplay.textContent = '••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••';
                nsecDisplay.setAttribute('data-hidden', 'true');
                toggleButton.textContent = 'show';
            }
}
        function showImportForm() {
    document.getElementById('generateSection').classList.add('hidden');
    document.getElementById('importSection').classList.remove('hidden');
    document.querySelector('.tagline').classList.add('hidden');
}

function cancelImport() {
    document.getElementById('importSection').classList.add('hidden');
    document.getElementById('generateSection').classList.remove('hidden');
    document.getElementById('importNsec').value = '';
    document.querySelector('.tagline').classList.remove('hidden');
}

function importKeys() {
    const nsecInput = document.getElementById('importNsec').value.trim();
    
    if (!nsecInput) {
        showValidationMessage('please enter an nsec key');
        return;
    }
    
    try {
        // Validate and decode the nsec
        const { data: privateKey } = window.NostrTools.nip19.decode(nsecInput);
        const publicKey = window.NostrTools.getPublicKey(privateKey);
        const npub = window.NostrTools.nip19.npubEncode(publicKey);
        
        // Store in state
        state.nsec = nsecInput;
        state.npub = npub;
        
        // Display keys (nsec starts hidden)
        document.getElementById('nsecDisplay').textContent = '••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••';
        document.getElementById('nsecDisplay').setAttribute('data-hidden', 'true');
        document.getElementById('npubDisplay').textContent = npub;
        
        // Show sections
        document.getElementById('importSection').classList.add('hidden');
        document.getElementById('keySection').classList.remove('hidden');
        document.getElementById('configSection').classList.remove('hidden');
        
        // Store keys
        KeyManager.store(nsecInput, npub);
        
        // Clear input
        document.getElementById('importNsec').value = '';
        
    } catch (error) {
        showValidationMessage('invalid nsec key. please check the format and try again.');
    }
}

function showBackupData() {
    const config = JSON.parse(localStorage.getItem('proof_config'));
    const keys = KeyManager.retrieve();
    
    const timestamp = new Date().toISOString().split('T')[0];
    const backupData = `PINGPROOF.LIFE Check-in Identity Backup
Created: ${timestamp}

Public Key (npub - share with check-in contact):
${keys.npub}

Private Key (nsec - KEEP SECRET):
${keys.nsec}

Check-in Contact: ${config.contactNpub}
Public Post: "${config.checkInMessage}"
Timer Interval: ${config.timerInterval / (1000 * 60 * 60)} hours`;

    document.getElementById('backupContent').textContent = backupData;
    document.getElementById('backupDisplay').classList.remove('hidden');
}

function downloadBackup() {
    showBackupData(); // Generate the backup data first
    
    const content = document.getElementById('backupContent').textContent;
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'pingproof.life-check-in-backup.txt';
    a.click();
    
    URL.revokeObjectURL(url);
}

function copyBackupData() {
    const content = document.getElementById('backupContent').textContent;
    try {
        navigator.clipboard.writeText(content);
    } catch (e) {
        console.warn('clipboard write failed (backup):', e);
        showValidationMessage('could not copy to clipboard');
        return;
    }
    
    const button = document.querySelector('#backupDisplay button');
    const originalText = button.textContent;
    button.textContent = 'copied!';
    button.style.background = 'var(--success)';
    button.style.color = '#ffffff';
    
    setTimeout(() => {
        button.textContent = originalText;
        button.style.background = '';
        button.style.color = '';
    }, 1000);
}

function actuallyStartTimer() {
    document.getElementById('setupScreen').classList.add('hidden');
    document.getElementById('timerScreen').classList.remove('hidden');
    
    // Start timer
    Timer.start();
    updateDeadlineDisplay();

    }

        function toggleConnectionInfo() {
            const infoPanel = document.getElementById('connectionInfo');
            infoPanel.classList.toggle('hidden');
        }

        function backToSetup() {
            // Stop the current timer
            clearInterval(state.countdownInterval);

            // Switch screens
            document.getElementById('timerScreen').classList.add('hidden');
            document.getElementById('setupScreen').classList.remove('hidden');
            
            // Reset to proper setup state - hide all sections except the ones needed
            document.getElementById('backupSection').classList.add('hidden');
            document.getElementById('keySection').classList.remove('hidden');
            document.getElementById('configSection').classList.remove('hidden');
            document.getElementById('generateSection').classList.add('hidden');
            
            // Hide tagline (since we're showing keys/config)
            document.querySelector('.tagline').classList.add('hidden');
            
            // Clear timer state but keep keys and config
            state.deadline = null;
            localStorage.removeItem('proof_deadline');
        }

        function showValidationMessage(message) {
            const msgDiv = document.getElementById('validationMessage');
            msgDiv.textContent = message;
            msgDiv.classList.remove('hidden');
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                msgDiv.classList.add('hidden');
            }, 3000);
        }

         // New function to handle deadline passed scenario
        function sendCheckInNow() {
            Timer.onExpire(); // This will send the check-in message
        }

        function clearEverythingAndRestart() {
            localStorage.clear();
            location.reload();
        }

        Timer.showDeadlinePassedScreen = function() {
            const now = new Date();
            const timePassed = now - state.deadline;
            const minutes = Math.floor(timePassed / (1000 * 60));
            
            // Hide existing screens
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('timerScreen').classList.add('hidden');
            
            // Create new screen element
            const deadlineScreen = document.createElement('div');
            deadlineScreen.innerHTML = `
                <h1>pingproof.life</h1>
                <div class="status" style="color: #dc3545; margin-bottom: 32px;">
                    deadline passed ${minutes} minutes ago
                </div>
                <div style="margin-bottom: 32px; font-size: 14px; color: var(--text-secondary);">
                    browser was closed - nothing posted
                </div>
                <button onclick="clearEverythingAndRestart()">start over</button>
            `;
            
            // Replace container content
            const container = document.querySelector('.container');
            container.innerHTML = '';
            container.appendChild(deadlineScreen);
        };

        Timer.showProtectionPausedScreen = function() {
            const now = new Date();
            const remaining = state.deadline - now;
            const hours = Math.floor(remaining / (1000 * 60 * 60));
            const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));

            // Calculate when timer was originally started
            const config = JSON.parse(localStorage.getItem('proof_config'));
            const originalStart = new Date(state.deadline - config.timerInterval);
            const hoursAgo = Math.floor((now - originalStart) / (1000 * 60 * 60));
            
            // Hide existing screens
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('timerScreen').classList.add('hidden');
            
            // Create protection paused screen
            const pausedScreen = document.createElement('div');
            pausedScreen.innerHTML = `
                <h1>pingproof.life</h1>
                <div class="status" style="color: var(--text-secondary); margin-bottom: 32px;">
                    timer paused - started ${hoursAgo}h ago
                </div>
                <div style="margin-bottom: 32px; font-size: 14px; color: var(--text-secondary);">
                    ${hours}h ${minutes}m remaining when browser closed
                </div>
                <button onclick="resumeCountdown()" style="margin-bottom: 16px;">resume countdown</button>
                <button onclick="startFreshTimer()" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary);">start fresh timer</button>
            `;
            
            // Replace container content
            const container = document.querySelector('.container');
            container.innerHTML = '';
            container.appendChild(pausedScreen);
        };

        Timer.showMessageSentScreen = function() {
            // Clear deadline since message was successfully sent
            localStorage.removeItem('proof_deadline');
            
            // Hide existing screens
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('timerScreen').classList.add('hidden');
            
            // Get the relay status from the connection status element
            const statusEl = document.getElementById('connectionStatus');
            let relayInfo = 'sent successfully';
            if (statusEl && statusEl.textContent.includes('sent to')) {
                relayInfo = statusEl.textContent.replace('[', '').replace(']', '');
            }
            
            // Create message sent screen
            const sentScreen = document.createElement('div');
            sentScreen.innerHTML = `
                <h1>pingproof.life</h1>
                <div class="status" style="color: var(--success); margin-bottom: 32px;">
                    check-in alert sent successfully
                </div>
                <div style="margin-bottom: 32px; font-size: 14px; color: var(--text-secondary);">
                    ${relayInfo}
                </div>
                <button onclick="clearEverythingAndRestart()" style="margin-bottom: 16px;">start over</button>
            `;
            
            // Replace container content
            const container = document.querySelector('.container');
            container.innerHTML = '';
            container.appendChild(sentScreen);
        };

        Timer.showMessageFailedScreen = function() {
            // Hide existing screens
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('timerScreen').classList.add('hidden');
            
            // Create message failed screen
            const failedScreen = document.createElement('div');
            failedScreen.innerHTML = `
                <h1>pingproof.life</h1>
                <div class="status" style="color: var(--danger); margin-bottom: 32px;">
                    failed to send check-in message
                </div>
                <div style="margin-bottom: 32px; font-size: 14px; color: var(--text-secondary);">
                    check your connection and try again
                </div>
                <button onclick="sendCheckInNow()" style="margin-bottom: 16px;">try again</button>
                <button onclick="clearEverythingAndRestart()" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary);">start over</button>
            `;
            
            // Replace container content
            const container = document.querySelector('.container');
            container.innerHTML = '';
            container.appendChild(failedScreen);
        };

        function startNewTimerFromSent() {
            // Keep keys and config, just clear the deadline and restart timer
            localStorage.removeItem('proof_deadline');
            state.deadline = null;
            
            // Reload page to restore full HTML structure, then start timer
            location.reload();
        }

        function resumeCountdown() {
            // Restore application state first
            const keys = KeyManager.retrieve();
            const config = JSON.parse(localStorage.getItem('proof_config'));
            
            state.nsec = keys.nsec;
            state.npub = keys.npub;
            
            // Restore the timer screen HTML structure
            const container = document.querySelector('.container');
            container.innerHTML = `
                <div id="setupScreen" class="hidden"></div>
                <div id="timerScreen">
                    <h1>pingproof.life</h1>
                    <button onclick="backToSetup()" class="back-button">← back to setup</button>
                    <div class="status" id="connectionStatus"></div>
                    <div class="timer" id="timerDisplay">00:00:00</div>
                    <div class="connection-info-link" onclick="toggleConnectionInfo()">
                        <span class="info-text">relay info</span>
                    </div>
                    <div id="connectionInfo" class="connection-details hidden">
                        <div class="detail-header">Check-in Relay System</div>
                        <div class="detail-text">
                            When timer expires, connects simultaneously to:<br>
                            relay.damus.io • nos.lol • relay.snort.social<br>
                            relay.primal.net • relay.nostr.band
                        </div>
                    </div>

                    <div class="deadline" id="deadlineDisplay">next deadline: --</div>
                    <div class="status" style="font-size: 12px; margin-bottom: 8px;">[timer runs only while tab is open; phone background unreliable]</div>
                    <div class="status" id="publicPostReminder">[check-in post will be public]</div>

                    <button onclick="checkIn(this)">i'm here</button>

                    <div style="margin-top: 40px;">
                        <button onclick="stopTimer()" style="font-size: 14px;">stop timer</button>
                        <div id="stopConfirmation" class="hidden" style="margin-top: 24px; text-align: center;">
                            <div style="margin-bottom: 16px; font-size: 14px; color: var(--text-secondary);">stop check-in timer?</div>
                            <button onclick="confirmStop()" style="font-size: 14px; margin-right: 8px;">yes, stop timer</button>
                            <button onclick="cancelStop()" style="font-size: 14px; background: transparent; border: 1px solid var(--border); color: var(--text-secondary);">cancel</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Now resume countdown with the restored elements
            Timer.updateCountdown();
            state.countdownInterval = setInterval(Timer.updateCountdown, 1000);
            updateDeadlineDisplay();
        }

        function startFreshTimer() {
            clearEverythingAndRestart();
        }
    </script>
</body>
</html>